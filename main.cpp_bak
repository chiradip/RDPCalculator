#include <iostream>

#include "Token.h"
//
// Created by Chiradip Mandal on 4/11/25.
//
#include "Calculator.h"
#include "constants.h"
#include "enums.h"
#include "SymbolTable.h"

#include "utility.h"
SymbolTable st; // allows Variable storage and retrieval
TokenStream *ts; // provides get() and putback()

double bitwise();
double expression(); // forward declaration for primary to call

double calc_sqrt() { // NOLINT: Clang-Tidy: Function 'calc_sqrt' is within a recursive call chain
    char ch;
    if (ts -> iss.get(ch) && ch != '(') throw runtime_error("'(' expected");
    cin.putback(ch);
    const double d = expression();
    if (d < 0) throw runtime_error("sqrt: negative val is imaginary");
    return sqrt(d);
}

double calc_pow() { // NOLINT: Clang-Tidy: Function 'calc_pow' is within a recursive call chain
    Token t = ts->get();
    if (t.kind != '(') throw runtime_error("'(' expected");
    double base = bitwise();
    t = ts->get();
    if (t.kind != ',') throw runtime_error("',' expected");
    const int power = narrow_cast<int>(bitwise());
    t = ts->get();
    if (t.kind != ')') throw runtime_error("')' expected");
    return pow(base, power);
}

double calc_sin() { // NOLINT: Clang-Tidy: Function 'calc_pow' is within a recursive call chain
    char ch;
    if (ts -> iss.get(ch) && ch != '(') throw runtime_error("'(' expected");
    ts->iss.putback(ch);
    const double d = expression();
    if (d == 0 || d == 180) return 0; // return true zero
    return sin(d * 3.1415926535 / 180);
}

double calc_cos() { // NOLINT: Clang-Tidy: Function 'calc_pow' is within a recursive call chain
    char ch;
    if (ts->iss.get(ch) && ch != '(') throw runtime_error("'(' expected");
    ts->iss.putback(ch);
    double d = expression();
    if (d == 90 || d == 270) return 0; // return 0 instead of 8.766e-11
    return cos(d * 3.1415926535 / 180);
}

double handle_variable(Token &t) { // NOLINT: Clang-Tidy: Function 'calc_pow' is within a recursive call chain
    if (const Token t2 = ts->get(); t2.kind == '=')
        return st.set_value(t.name, expression());
    else {
        ts->putback(t2);
        return st.get_value(t.name); // missing in text!
    }
}

/**
 * input grammar functions. deal with numbers and parenthesis
 * ex 2 - added '{' case
*/
double primary() { // NOLINT: Clang-Tidy: Function 'calc_pow' is within a recursive call chain
    cout << "primary()" << endl;
    switch (Token t = ts->get(); t.kind) {
        // handle '(' expression ')'
        case '(': {
            const double d = bitwise();
            t = ts->get();
            if (t.kind != ')') throw runtime_error("')' expected");
            return d;
        }
        case '{': {
            const double d = bitwise();
            t = ts->get();
            if (t.kind != '}') throw runtime_error("'}' expected");
            return d;
        }
        case NUMBER:
            cout << "t.value = " << t.value << endl;
            cout << "t.name = " << t.name << endl;
            return t.value; // return the number's value
        case NAME:
            cout << "handle_variable being called" << t.name << endl;
            return handle_variable(t);
        case '-':
            return -primary();
        case '+':
            return primary();
        case SQ_ROOT:
            return calc_sqrt();
        case EXPONENT:
            return calc_pow();
        case C_SIN:
            return calc_sin();
        case C_COS:
            return calc_cos();
        default:
            throw runtime_error("primary expected");
    }
}

// ex 3 - Add a factorial operator '!'
double secondary() { // NOLINT: Clang-Tidy: Function 'calc_pow' is within a recursive call chain
    cout << "secondary()" << endl;
    double left = primary();
    Token t = ts->get();

    while (true) {
        switch (t.kind) {
            case '!':
                if (left == 0) return 1;
                for (int i = static_cast<int>(left) - 1; i > 0; --i) left *= i;
                t = ts->get();
                break;
            default:
                ts->putback(t);
                return left;
        }
    }
}

// deal with * and /
double term() { // NOLINT: Clang-Tidy: Function 'calc_pow' is within a recursive call chain
    cout << "term()" << endl;
    double left = secondary();
    Token t = ts->get(); // get next token from Token_stream

    while (true) {
        switch (t.kind) {
            case '*':
                left *= secondary();
                t = ts->get();
                break;
            case '/': {
                double d = secondary();
                if (d == 0) throw runtime_error("divide by zero");
                left /= d;
                t = ts->get();
                break;
            }
            case '%': {
                double d = secondary();
                if (d == 0) throw runtime_error("%: divide by zero");
                left = fmod(left, d);
                t = ts->get();
                break;
            }
            default:
                ts->putback(t); // put t back into the Token_stream
                return left;
        }
    }
}

// deal with + and -
double expression() { // NOLINT: Clang-Tidy: Function 'expression' is within a recursive call chain
    cout << "expression()" << endl;
    double left = term(); // read and evaluate a term
    Token t = ts->get(); // get next token from Token_stream

    while (true) {
        switch (t.kind) {
            case '+':
                left += term(); // evaluate term and add
                t = ts->get();
                break;
            case '-':
                left -= term(); // evaluate term and subtract
                t = ts->get();
                break;
            default:
                ts->putback(t); // put t back into the token stream
                return left;
        }
    }
}

/**
 * deal with &, |, ^ and ~
 * bitwise operators only work on integers so all double results are cast
 * to integers via C-style casting
 */
double bitwise() { // NOLINT: Clang-Tidy: Function 'calc_pow' is within a recursive call chain
    cout << "bitwise()" << endl;
    Token t = ts->get(); // check for unary ~
    if (t.kind == '~')
        return ~static_cast<int>(expression());
    ts->putback(t);

    double left = expression();
    t = ts->get();

    while (true) {
        switch (t.kind) {
            case '&':
            case '|':
            case '^': {
                int temp = static_cast<int>(left);
                switch (t.kind) {
                    case '&':
                        temp &= static_cast<int>(expression());
                        break;
                    case '|':
                        temp |= static_cast<int>(expression());
                        break;
                    case '^':
                        temp ^= static_cast<int>(expression());
                        break;
                    default:
                        // no default
                        break;
                }
                left = temp;
                t = ts->get();
            }
            break;
            default:
                ts->putback(t);
                return left;
        }
    }
}

/**
 * assume we have seen "let"
 * handle: name = expression
 * declare a variable called "name" with the initial value "expression"
 */
double declaration() {
    cout << "declaration()" <<endl;
    const Token t = ts->get();
    if (t.kind != NAME) throw runtime_error("name expected in declaration");
    const string var_name = t.name;
    cout << "t.name = " << var_name << endl;

    if (const Token t2 = ts->get(); t2.kind != '=') throw runtime_error("= missing in declaration of " + var_name);

    const double d = bitwise();
    cout << "d = " << d << endl;
    st.define_name(var_name, d);
    return d;
}

double statement() {
    cout << "statement()" << endl;
    switch (const Token t = ts->get(); t.kind) {
        case LET:
            cout << "t.kind = " << t.kind << endl;
            return declaration();
        default:
            ts->putback(t);
            return bitwise();
    }
}

void print_help() {
    cout << "Simple Calculator Manual\n"
            << "========================\n"
            << "This calculator program supports +, -, *, and / operations\n"
            << "Enter any form of compound statement followed by ';' for result\n"
            << "- ex: 4 + 1; (5-2)/{6*(8+14)}\n"
            << "The modulo operator % may be used on all numbers\n"
            << "An '!' placed after a value will calculate the factorial of it\n"
            << "- ex: 4! = 4 * 3 * 2 * 1\n"
            << "Square root and exponentiation are provided by 'sqrt' and 'pow'\n"
            << "- ex: sqrt(25) = 5, pow(5,2) = 25\n"
            << "Variable assignment is provided using the 'let' keyword:\n"
            << "- ex: let x = 37; x * 2 = 74; x = 4; x * 2 = 8\n\n";
}

// expression evaluation loop
// ยง7.7 recovering from errors
void clean_up_mess() {
    ts->ignore(PRINT);
}

void calculate() {
    string s;
    while (cin >> s)
        try {
            cout << prompt;

            //cin >> s;
            istringstream iss(s);
            ts = new TokenStream(std::move(iss));
            Token t = ts->get();
            while (t.kind == PRINT) t = ts->get(); // discard extra 'prints'
            if (t.kind == HELP) print_help();
            else if (t.kind == QUIT) return;
            else {
                ts->putback(t);
                cout << result << statement() << '\n';
            }
        } catch (exception &e) {
            cerr << e.what() << '\n'; // write error message to user
            //clean_up_mess();
            cout << endl;
            //ts = new TokenStream();
        }
}

double calculate(const string& expr) {
    istringstream iss(expr);
    ts = new TokenStream(std::move(iss));
    return statement();
}

int main2() {
    calculate("let a = 2;");
    calculate("let b = 3;");
    const double res = calculate("(a+b+3*2+3)\n");
    const double res2 = calculate("{2+3*3}*a/b + (2+3)*4;");
    cout << "res = " << res << '\n';
    cout << "res2 = " << res2 << '\n';
    return 0;
}
int main3() {
    Calculator calculator = Calculator();
    double d = calculator.statement("2+2;");
    cout << "d = " << d << '\n';
    return 0;
}
